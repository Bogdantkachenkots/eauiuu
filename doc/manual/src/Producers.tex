% !TEX root = EUDAQUserManual.tex
\section{Writing a Producer}\label{sec:ProducerWriting}
Producers are the binding part between a user DAQ and the central EUDAQ Run Control.
A Producer consistes of a CommandReceiver and a DataSender, where the first receives commands from the Run Control while the latter allows to send binary data events to the Data Collector.
A Producer base class is provided in order to simplify the integration.
The Producer is compiled against the EUDAQ library which implements all of the required communication over the network.
Example code for producers is provided, see \autoref{sec:ExampleProducer}.


\subsection{Example Source Code}\label{sec:Ex0Producer_cc}
\myinputlisting{-60}{user/example/module/src/Ex0Producer.cc}
\newpage

\subsection{Register }


\subsection{Receiving Commands}
The Run Control distributs commands to all registered clients, controlling the global finite state machine and thus the DAQ.
Whenever a user input is received from the Run Control, the corresponding member function of the Producer will be invoked.
These member functions of the Producer class are virtual and can be overloaded by the user in their respective Producer implementations.
The \texttt{Producer} base class definition is provided in the header file:
\begin{listing}
#include "eudaq/Producer.hh"
\end{listing}

\subsubsection{DoInitialise}
This method is called whenever an initialise command is received from the Run Control.
The method signature is:
\begin{listing}
virtual void OnInitialise(const eudaq::Configuration & config);
\end{listing}

The configuration object is received from the Run Control. The Producer is free to read any part of the configuration object but parameters cannot be changed owing to the const qualifier.

If the initialisation step is not required for a certain DAQ, the function can be left unimplemented in the Producer. In that case the corresponding member function of the \texttt{CommandReceiver} base class is executed.

\subsubsection{DoConfigure}\label{sec:OnConfigure}
This method is called whenever a configure command is received from the Run Control.
The method signature is:
\begin{listing}
virtual void OnConfigure(const eudaq::Configuration & config);
\end{listing}

The configuration object is received from the Run Control where is has been loaded from a user configurable file. The Producer is free to read any part of the configuration object but parameters cannot be changed owing to the const qualifier.


\subsubsection{DoStartRun}
This is called on the start of each run.
The method signature is:
\begin{listing}
virtual void OnStartRun(unsigned param);
\end{listing}

As a parameter, it receives the run number of the started run.
The Producer must send a \gls{BORE},
and then enable the data acquisition on the attached devices and prepare for receiving events from the hardware.


\subsubsection{DoStopRun}
This is called at the end of the run.
The method signature is simply:
\begin{listing}
virtual void OnStopRun();
\end{listing}

Care should be taken that there are no more events pending to be read out.
Once all data events have been sent, an \gls{EORE} should also be sent,
to signal to the DAQ that the Producer has ended the run successfully.

\subsection{Sending Data and the RawDataEvent class}
Events may be sent to the DAQ using the \texttt{Producer}'s \texttt{SendEvent()} method
that has the following signature:
\begin{listing}
void SendEvent(const Event &);
\end{listing}

It takes as a parameter an object derived from the \texttt{eudaq::Event} base class
that will be serialised and sent to the Data Collector.
In practice it will usually be of the type \texttt{RawDataEvent}.

The \texttt{RawDataEvent} is a generic container for blocks of binary data and is used to encapsulate the data read directly from the devices and send it to the central DAQ for storage.
Each \texttt{RawDataEvent} may contain any number of raw data blocks.
By convention each block usually corresponds to one sensor,
but this is not required;
it is up to each Producer how the raw data are encoded.
The RawDataEvent class is defined in the following header file:
\begin{listing}
#include "eudaq/RawDataEvent.hh"
\end{listing}

The class is described in the following in more detail.

\subsubsection{Constructor}
A \texttt{RawDataEvent} is constructed as follows:
\begin{listing}
RawDataEvent event("EXAMPLE", run, event);
\end{listing}

Where \texttt{"EXAMPLE"} is a string unique to the particular producer
that will be used by the event decoding factory to select the correct converter during decoding.
The \texttt{run} and \texttt{event} parameters are the run number
and event number, respectively.

Furthermore, the producer is required to send a \gls{BORE}
and \gls{EORE} at the beginning and end of a run respectively.
These are regular \texttt{RawDataEvent} objects with a particular flag set.
For convenience, separate methods are available to create the respective event types:
\begin{listing}
RawDataEvent::BORE("EXAMPLE", run);
RawDataEvent::EORE("EXAMPLE", run, event);
\end{listing}

These methods return a \texttt{RawDataEvent} that may be either be sent directly to the DAQ,
or be modified first, e.g. by setting tags as described below in \autoref{sec:Tags}.

\subsubsection{Adding Data}
Once a RawDataEvent has been constructed,
data blocks may be added either using a vector:
\begin{listing}
std::vector<unsigned char> buffer = ...;
event.AddBlock(id, buffer);
\end{listing}

or using a pointer to a block of memory, and a length in bytes:
\begin{listing}
unsigned char * buffer = ...;
event.AddBlock(id, buffer, len);
\end{listing}

Where \texttt{id} is an integer used to uniquely identify the different blocks.
The \texttt{buffer} variable points to the actual data for the block under consideration block and can be provided either as STL \texttt{vector}, where the full vector is read and sent, or as C-pointer to a memory block where the \texttt{len} argument is required to specify the size.

The type of the vector or data array can be freely chosen by the user since the data serializers are implemented as templates.
However, if data types larger than \texttt{char} are used, special care has to be taken for appropriate endianness of the data.
This is especially true if the producer and decoding software run on different machines which might have different architectures.


\subsubsection{Tags}\label{sec:Tags}
\texttt{RawDataEvent} objects as well as other types inheriting from the \texttt{Event} base class also provide the option to store tags.
Tags are name-value pairs containing additional information which does not qualify as regular DAQ data which is written in the binary blocks.
Particularily in the \gls{BORE} this is very useful to store information about the exact sensor configuration which micht be required in order to be able to decode the raw data stored.
A tag is stored as follows:
\begin{listing}
event.SetTag("Temperature", 42);
\end{listing}

The value corresponding to the tag can be set as an arbitrary type (in this case an integer),
it will be converted to a STL string internally.

